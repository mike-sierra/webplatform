

=Session History=

Traditionally, web content was organized around the idea of traversing
links from one static page to another. Web apps are deployed much
differently: as a fixed set of files that access data dynamically,
typically via Ajax. Such an application may change its interface
dramatically from within a single web page. HTML5's History API
offers a standard way to access different application states using the
browser's familiar navigation controls.

==Session History==

A browser's session history is available via '''window.history'''. The
following test confirms a browser's support for the History API:

<pre>
var supportsHistory = !!window.history.pushState;
</pre>

The '''history''' object supports the following basic properties and
methods:

* '''history.length''': the total number of history entries.

* '''history.back()''' navigate backward through browser history.

* '''history.forward()''': navigate forward through browser history.

* '''history.go(n)''': jump forward in history ''n'' pages, or back
''-n'' pages.

'''Note:''' If they are to use session history to maintain state, [[full-screen applications]] that remove browser controls
from the screen must provide their own set of controls that call
these methods.

Applications can use the '''pushState()''' method to generate their own
custom history entries and associate data with them.

The example described below allows users to undo sets of changes to an
[[editable block of text]]. The text's
'''contenteditable''' attribute allows users to edit it:

<pre>
<div id="historic" contenteditable="true">
Make sets of changes, then go back in history to progressively revert.
</div>
</pre>

Like form inputs, tapping on editable text regions fires a '''focus'''
event. The handler below is activated by the '''blur''' event that fires
when users tap outside the editable text:

<pre>
var e = 0;
document.querySelector('#historic').addEventListener('blur', newEdit);

function newEdit(event) {
    window.history.pushState(
       {text: JSON.stringify(event.target.innerHTML)}, ++e, "?edit="+e);
};
</pre>

The '''history.pushState()''' method accepts three values:

* the data to be retained, represented as a JSON object

* an optional title

* a unique same-domain URL component, in this case a filename suffix

In this case, the data is the text that has just been edited, and the
URL component is an attribute referencing an incrementing integer.

'''Note:''' The '''history.replaceState()''' method works much the same as
'''pushState()''', but only modifies the ''current'' history entry.

Tapping the browser's control to go back to the previous page (or
corresponding application control) fires the window's '''popstate'''
event. Cached data is available via specified fields within
'''event.state''':

<pre>
window.addEventListener('popstate', revertEdit);

function revertEdit(event) {
    document.querySelector('#historic').innerHTML = JSON.parse(event.state.text);
}
</pre>

The following example demonstrates an undo-able editing interface for
many different fields:

[[Image:scr_storage_history.png]]

'''Note:''' The example uses the browser's [[storage]] to save
batches of edits, so that they are not lost if users refresh the page.
The option to clear edits clears the storage area and reloads the
original markup.

When pushing new history entries, note that transient custom URLs
generated by '''pushState()''' and '''replaceState()''' do not correspond
to any server-generated content, and thus may cause confusion when
reloaded or bookmarked as home-screen applications.

==SIDEBAR Navigational Selector==

Elements within a page that are the target of navigation can receive
distinct styling using the ''':target''' dynamic class. The act of
navigating to an element can alter its appearance, or even determine
if it is to appear at all.

The following example relies on anchor navigation to display
successive rows of a table within a mobile interface:

[[Image:scr_layout_tbl-keyhole.png]]

While the example relies on table-related tags, they are re-styled
with block formatting to confine each row of information within the
screen. Each row features links to other rows, triggering their
display. Other links navigate away from the table, which suppresses
its display altogether. This is the main CSS driving the interface:

<pre>
.mobile > tbody > tr        { display : none  }
.mobile > tbody > tr:target { display : block }
</pre>

The same technique may be used to display or dismiss optional
interface elements such as panels, simply by providing navigation
links to them within the page.

'''Note:''' Navigation to internal anchor links results in new
history entries along with distinct URLs that correspond to
application states. In the sample above, users may bookmark or share
individual items of interest. Otherwise for less substantial content,
consider defining your own classes. Navigating to anchors that appear
offset from the top of the screen, or horizontally off-screen, may
also abruptly shift the viewable window.

==Navigation Within a Page==

Short of generating custom history entries, a mobile web app can use
more conventional navigation techniques to control an application's
state.

The example below demonstrates how a panel implemented as an element
within a page may be hidden by default, and displayed when users
navigate to it. The ''':target''' dynamic CSS class allows elements to
be styled differently if they have been accessed via direct
navigation:

<pre>
<style>
#panel {
    display  : none;
}
#panel:target {
    display  : block;
    position : absolute;
    left     : 1em;
    top      : 1em;
    right    : 1em;
    bottom   : 1em;
}
</style>

<a href="#panel">Settings...</a>

<section id="panel">
    <a href="#">[X]</a>
</section>
</pre>

The following example shows an interface designed to make table rows
more accessible on smaller mobile screens, by restyling their data as
vertically stacked blocks. Rows are hidden by default, and display
only if they are the target of navigation:

[[Image:scr_layout_tbl-keyhole.png]]

Such navigation to elements within a page results in new history
entries, but can also be tracked using the window's '''hashchange'''
event. Its '''oldURL''' and '''newURL''' properties provide context for
each change in application state. The example above uses a
'''hashchange''' handler to modify the title of the page.

'''Note:''' When using navigation to drive an interface in the manner described
above, each navigation results in a new history entry, which may
become annoying to users who try to step back to a prior page. But
there may also be an advantage in being able to share or save URLs
referencing specific items of interest.

[[Image:history.png]]

